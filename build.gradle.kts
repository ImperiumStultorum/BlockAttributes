// This is to suppress false warnings generated by a bug in IntelliJ
@file:Suppress("DSL_SCOPE_VIOLATION", "MISSING_DEPENDENCY_CLASS", "FUNCTION_CALL_EXPECTED")

import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import org.jetbrains.kotlin.gradle.dsl.KotlinProjectExtension
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile
import kotlin.reflect.KClass

fun getPropStr(name: String): String = property(name).toString()
fun getVer(name: String): String = getPropStr("v${name.replaceFirstChar(Char::uppercaseChar)}")

val snapshotRegex = Regex("-((beta)|(alpha))$")
val javaVer = JavaVersion.toVersion(getVer("java"))
val id = getPropStr("id")

// ordinal + 1 is how javaVer.majorVersion is calculated, and saves needless string conversion
fun JavaVersion.toInt() = this.ordinal + 1

plugins {
	java
	`maven-publish`

	// for some godforsaken reason you can't seem to access properties in `plugins`, so here and only here has constants.
	id("org.jetbrains.kotlin.jvm").version("1.9.10")
	id("org.quiltmc.loom").version("1.+")
}

buildscript {
    dependencies {
        // Same thing as above
        classpath("com.squareup:kotlinpoet:1.16.0")
    }
}

repositories {
	maven {
		name = "Imperium"
		url = uri("https://maven.stultorum.com/releases")
	}
}

loom {
	accessWidenerPath = file("src/main/resources/$id.accesswidener")
	mods {
        
	}
}

dependencies {
	val minecraftVer = getVer("minecraft")
	minecraft("com.mojang:minecraft:$minecraftVer")
	mappings("org.quiltmc:quilt-mappings:$minecraftVer+build.${getVer("mappings")}:intermediary-v2")

	modImplementation("org.quiltmc:quilt-loader:${getVer("loader")}")
	modImplementation("org.quiltmc.quilted-fabric-api:quilted-fabric-api:${getVer("QFAPI")}+${getVer("FAPI")}-$minecraftVer")

	val qklVer = getVer("QKL")
	val ktVer = getVer("kotlin")
	val flkVer = getVer("FLK")
	modImplementation("org.quiltmc.quilt-kotlin-libraries:quilt-kotlin-libraries:$qklVer+kt.$ktVer+flk.$flkVer")
	modImplementation("org.quiltmc.quilt-kotlin-libraries:core:$qklVer+kt.$ktVer+flk.$flkVer")
	modImplementation("org.quiltmc.quilt-kotlin-libraries:library:$qklVer+kt.$ktVer+flk.$flkVer")
    
    modImplementation("com.stultorum.quiltmc:blunders:${getVer("blunders")}")
}

tasks {
	withType<KotlinCompile> {
        dependsOn += "genPoet"
		kotlinOptions {
			jvmTarget = javaVer.majorVersion
			// languageVersion: A.B of the kotlin plugin version A.B.C
			languageVersion = getVer("kotlin").substringBeforeLast('.')
		}
	}

	withType<JavaCompile>.configureEach {
		options.encoding = "UTF-8"
		options.isDeprecation = true
		options.release.set(javaVer.toInt())
	}
    
    register("genPoet") {
        doLast { Poet().genAll() }
    }

	named("publish") {
		enabled = false
	}
	register("publishRelease") {
		dependsOn("publish${rootProject.name.replaceFirstChar(Char::uppercaseChar)}PublicationToReleaseRepository")
	}
	register("publishBeta") {
		if (!project.version.toString().matches(snapshotRegex)) throw GradleException("Beta publication doesn't match snapshot regex")
		dependsOn("publish${rootProject.name.replaceFirstChar(Char::uppercaseChar)}PublicationToSnapshotRepository")
	}

	processResources {
		filteringCharset = "UTF-8"
        duplicatesStrategy = DuplicatesStrategy.INCLUDE
        
        filesMatching("quilt.mod.json") {
            expand(
                mapOf(
                    "group" to project.group,
                    "id" to getPropStr("mc_id"),
                    "name" to id,
                    "version" to project.version,
                    "mainClass" to getPropStr("mainClass"),
                    "prettyName" to getPropStr("prettyName"),
                    "desc" to getPropStr("desc"),
                    "homePage" to getPropStr("homeUrl"),
                    "repoPage" to "https://${getPropStr("repoUrn")}",
                    "vLoader" to getVer("loader"),
                    "vQFAPI" to getVer("QFAPI"),
                    "vQKL" to getVer("QKL"),
                    "vBlunders" to getVer("blunders"),
                    "vMinecraft" to getVer("minecraft")
                )
            ) 
        }
	}

	javadoc {
		options.encoding = "UTF-8"
	}

	// Run `./gradlew wrapper --gradle-version <newVersion>` or `gradle wrapper --gradle-version <newVersion>` to update gradle scripts
	// BIN distribution should be sufficient for the majority of mods
	wrapper {
		distributionType = Wrapper.DistributionType.BIN
	}

	jar {
        exclude("com/stultorum/quiltmc/blockAttributes/poet/**")
		from("LICENSE") {
			rename { "LICENSE_${id}" }
		}
	}
}

if (JavaVersion.current() < javaVer) {
	kotlin.jvmToolchain(javaVer.toInt())

	java.toolchain {
		languageVersion.set(JavaLanguageVersion.of(javaVer.toInt()))
	}
}

java {
	withSourcesJar()
	withJavadocJar()

	sourceCompatibility = javaVer
	targetCompatibility = javaVer
}


publishing {
	publications {
		register<MavenPublication>(rootProject.name) {
			groupId = project.group.toString()
			artifactId = id
			version = project.version.toString()

			pom {
				val repoUrn = getPropStr("repoUrn")

				name = getPropStr("prettyName")
				description = getPropStr("desc")
				url = getPropStr("homeUrl")
				licenses {
					name = "LGPL-3.0"
					url = "https://www.gnu.org/licenses/lgpl-3.0.txt"
				}
				scm {
					connection = "scm:git:git://${repoUrn}.git"
					developerConnection = "scm:git:ssh://git@${repoUrn}.git"
					url = "https://${repoUrn}"
				}
			}

			from(components.getByName("java"))
		}
	}

	//See https://docs.gradle.org/current/userguide/publishing_maven.html for information on how to set up publishing.
	repositories {
		// In gradle publish, use -PreleaseUsername={token} -PreleasePassword={secret}
		maven {
			name = "release"
			url = uri("https://maven.stultorum.com/releases")
			credentials(PasswordCredentials::class)
			authentication {
				create<BasicAuthentication>("basic")
			}
		}
		// In gradle publish, use -PsnapshotUsername={token} -PsnapshotPassword={secret}
		maven {
			name = "snapshot"
			url = uri("https://maven.stultorum.com/snapshots")
			credentials(PasswordCredentials::class)
			authentication {
				create<BasicAuthentication>("basic")
			}
		}
	}
}

// Done this way for namespacing (Poet().genAll()) 
private class Poet {
    fun genAll() {
        val src = project.extensions.getByType<KotlinProjectExtension>().sourceSets.main.get().kotlin.srcDirs.first()
        
        makePrimitiveSerializers().writeTo(src)
    }
    
    companion object {
        private const val FILE_HEADER = """
           /--------------------------\
           |                          |
           | GENERATED BY KOTLIN POET |
           |                          |
           \--------------------------/
        """
        
        private val NbtCompoundType = ClassName.bestGuess("net.minecraft.nbt.NbtCompound")
        private val CompoundSerializerType = ClassName.bestGuess("com.stultorum.quiltmc.blockAttributes.nbt.CompoundSerializer")
        private val NbtPrimitiveTypes = arrayOf(String::class, Boolean::class, Byte::class, Short::class, Int::class, Long::class, Float::class, Double::class, ByteArray::class, IntArray::class, LongArray::class)
        
        fun makePrimitiveSerializers(): FileSpec {
            val file = FileSpec.builder("com.stultorum.quiltmc.blockAttributes.nbt", "PrimitiveSerializers")
            
            file.addFileComment(FILE_HEADER)
            
            file.addKotlinDefaultImports()
            file.addImport("org.quiltmc.qkl.library.nbt", "nbt", "NbtCompound")
            file.addAliasedImport(NbtCompoundType, "NbtCompoundType")
            
            file.addAnnotation(AnnotationSpec.builder(Suppress::class).addMember("\"RedundantVisibilityModifier\"").build())
            
            for (type in NbtPrimitiveTypes) {
                file.addType(makePrimitiveSerializer(type))
            }
            
            return file.build()
        }
        
        fun makePrimitiveSerializer(type: KClass<*>): TypeSpec {
            val name = type.simpleName!!.replaceFirstChar { c -> c.uppercaseChar() }
            return TypeSpec.classBuilder("${name}CompoundSerializer")
                .superclass(CompoundSerializerType.parameterizedBy(type.asTypeName()))
                .addFunction(FunSpec.builder("serialize")
                    .addModifiers(KModifier.OVERRIDE)
                    .addParameter("obj", type)
                    .returns(NbtCompoundType)
                    .addCode(CodeBlock.of("return NbtCompound(Pair(\"val\", obj.nbt))"))
                    .build()
                ).addFunction(FunSpec.builder("deserialize")
                    .addModifiers(KModifier.OVERRIDE)
                    .addParameter("nbt", NbtCompoundType)
                    .returns(type)
                    .addCode(CodeBlock.of("return nbt.get${name}(\"val\")"))
                    .build()
                ).build()
        }
    }
}


